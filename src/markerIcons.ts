import * as leaflet from 'leaflet';

// import '@fortawesome/fontawesome-free/js/all.min';
import { fas } from '@fortawesome/free-solid-svg-icons';
import { far } from '@fortawesome/free-regular-svg-icons';
import { fab } from '@fortawesome/free-brands-svg-icons';
import {
    library,
    IconPrefix,
    IconName,
    config as faConfig,
    findIconDefinition,
    icon as faIcon,
} from '@fortawesome/fontawesome-svg-core';

import 'leaflet-extra-markers';
import 'leaflet-extra-markers/dist/css/leaflet.extra-markers.min.css';
// Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
// @ts-ignore
let localL = L;
import wildcard from 'wildcard';

import { MarkerIconRule } from 'src/settings';

export function getIconFromRules(
    tags: string[],
    rules: MarkerIconRule[],
    iconFactory: IconFactory
) {
    // We iterate over the rules and apply them one by one, so later rules override earlier ones
    let result = rules.find((item) => item.ruleName === 'default').iconDetails;
    for (const rule of rules) {
        if (checkTagPatternMatch(rule.ruleName, tags)) {
            result = Object.assign({}, result, rule.iconDetails);
        }
    }
    return getIconFromOptions(result, iconFactory);
}

export function getIconFromOptions(
    iconSpec: leaflet.ExtraMarkers.IconOptions,
    iconFactory: IconFactory
): leaflet.Icon {
    // Ugly hack for obsidian-leaflet compatability, see https://github.com/esm7/obsidian-map-view/issues/6
    // @ts-ignore
    const backupL = L;
    try {
        // @ts-ignore
        L = localL;
        // We check for iconSpec.icon to allow a custom innerHTML specification for some rules,
        // and in such a case, do not wish to override the innerHTML by the icon rendition. See getIconFromRules above
        if (iconSpec.icon) {
            if (isFontAwesome(iconSpec.icon)) {
                // The behavior of Leaflet Extra Markers is to render Font Awesome with Web Fonts & CSS, which has
                // proven too slow for displaying hundreds of markers.
                // This overrides the HTML generated by Extra Market to use the SVG Symbols alternative, which
                // seems much faster.
                // See here for more details: https://fontawesome.com/v5/docs/web/advanced/svg-symbols
                iconSpec.innerHTML = iconFactory.getIcon(iconSpec).outerHTML;
            } else if (isText(iconSpec.icon)) {
                // Emoji or other short textual icon
                const color = iconSpec.iconColor ?? 'white';
                iconSpec.innerHTML = `<p class="mv-emoji-icon" style="color:${color}">${iconSpec.icon}</p>`;
            }
        }
        return leaflet.ExtraMarkers.icon(iconSpec);
    } finally {
        // @ts-ignore
        L = backupL;
    }
}

function isFontAwesome(iconName: string) {
    if (iconName.startsWith('fa-')) return true;
}

function isText(iconName: string) {
    return iconName.length <= 2;
}

// Utilizes the SVG capabilities of Font Awesome to generate icons, instead of using Web Fonts.
// Since we create the SVGs directly where they are needed, we can affort to turn off the slow
// Font Awesome MutationObserver, see the issue here: https://github.com/esm7/obsidian-map-view/issues/216
export class IconFactory {
    constructor(containerEl: HTMLElement) {
        faConfig.observeMutations = false;
        faConfig.autoReplaceSvg = false;
        library.add(fas, far, fab);
    }

    getIcon(iconSpec: leaflet.ExtraMarkers.IconOptions): SVGElement {
        const iconName = iconSpec.icon.replace('fa-', '') as IconName;
        const newIconDef = findIconDefinition({
            prefix: iconSpec.prefix as IconPrefix,
            iconName: iconName,
        });
        if (!newIconDef) return null;
        const newIcon = faIcon(newIconDef);
        if (!newIcon) return null;
        const iconNode = newIcon.node[0] as SVGElement;
        iconNode.style.color = iconSpec.iconColor ?? 'white';
        return iconNode;
    }
}

export function checkTagPatternMatch(tagPattern: string, tags: string[]) {
    let match = wildcard(tagPattern, tags);
    return match && match.length > 0;
}
